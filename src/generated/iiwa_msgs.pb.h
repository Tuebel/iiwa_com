// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: iiwa_msgs.proto

#ifndef PROTOBUF_iiwa_5fmsgs_2eproto__INCLUDED
#define PROTOBUF_iiwa_5fmsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_iiwa_5fmsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsWrapperMsgImpl();
void InitDefaultsWrapperMsg();
void InitDefaultsCartesianStateRequestImpl();
void InitDefaultsCartesianStateRequest();
void InitDefaultsCartesianStateImpl();
void InitDefaultsCartesianState();
void InitDefaultsCartesianPoseRequestImpl();
void InitDefaultsCartesianPoseRequest();
void InitDefaultsCartesianPoseImpl();
void InitDefaultsCartesianPose();
void InitDefaultsCartesianForceRequestImpl();
void InitDefaultsCartesianForceRequest();
void InitDefaultsCartesianForceImpl();
void InitDefaultsCartesianForce();
inline void InitDefaults() {
  InitDefaultsWrapperMsg();
  InitDefaultsCartesianStateRequest();
  InitDefaultsCartesianState();
  InitDefaultsCartesianPoseRequest();
  InitDefaultsCartesianPose();
  InitDefaultsCartesianForceRequest();
  InitDefaultsCartesianForce();
}
}  // namespace protobuf_iiwa_5fmsgs_2eproto
namespace iiwa_com {
class CartesianForce;
class CartesianForceDefaultTypeInternal;
extern CartesianForceDefaultTypeInternal _CartesianForce_default_instance_;
class CartesianForceRequest;
class CartesianForceRequestDefaultTypeInternal;
extern CartesianForceRequestDefaultTypeInternal _CartesianForceRequest_default_instance_;
class CartesianPose;
class CartesianPoseDefaultTypeInternal;
extern CartesianPoseDefaultTypeInternal _CartesianPose_default_instance_;
class CartesianPoseRequest;
class CartesianPoseRequestDefaultTypeInternal;
extern CartesianPoseRequestDefaultTypeInternal _CartesianPoseRequest_default_instance_;
class CartesianState;
class CartesianStateDefaultTypeInternal;
extern CartesianStateDefaultTypeInternal _CartesianState_default_instance_;
class CartesianStateRequest;
class CartesianStateRequestDefaultTypeInternal;
extern CartesianStateRequestDefaultTypeInternal _CartesianStateRequest_default_instance_;
class WrapperMsg;
class WrapperMsgDefaultTypeInternal;
extern WrapperMsgDefaultTypeInternal _WrapperMsg_default_instance_;
}  // namespace iiwa_com
namespace iiwa_com {

// ===================================================================

class WrapperMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.WrapperMsg) */ {
 public:
  WrapperMsg();
  virtual ~WrapperMsg();

  WrapperMsg(const WrapperMsg& from);

  inline WrapperMsg& operator=(const WrapperMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WrapperMsg(WrapperMsg&& from) noexcept
    : WrapperMsg() {
    *this = ::std::move(from);
  }

  inline WrapperMsg& operator=(WrapperMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WrapperMsg& default_instance();

  enum MsgCase {
    kCartesianForce = 1,
    kCartesianPose = 2,
    kCartesianState = 3,
    kCartesianForceRequest = 4,
    kCartesianPoseRequest = 5,
    kCartesianStateRequest = 6,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WrapperMsg* internal_default_instance() {
    return reinterpret_cast<const WrapperMsg*>(
               &_WrapperMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(WrapperMsg* other);
  friend void swap(WrapperMsg& a, WrapperMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WrapperMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  WrapperMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WrapperMsg& from);
  void MergeFrom(const WrapperMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WrapperMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iiwa_com.CartesianForce cartesian_force = 1;
  bool has_cartesian_force() const;
  void clear_cartesian_force();
  static const int kCartesianForceFieldNumber = 1;
  const ::iiwa_com::CartesianForce& cartesian_force() const;
  ::iiwa_com::CartesianForce* release_cartesian_force();
  ::iiwa_com::CartesianForce* mutable_cartesian_force();
  void set_allocated_cartesian_force(::iiwa_com::CartesianForce* cartesian_force);

  // .iiwa_com.CartesianPose cartesian_pose = 2;
  bool has_cartesian_pose() const;
  void clear_cartesian_pose();
  static const int kCartesianPoseFieldNumber = 2;
  const ::iiwa_com::CartesianPose& cartesian_pose() const;
  ::iiwa_com::CartesianPose* release_cartesian_pose();
  ::iiwa_com::CartesianPose* mutable_cartesian_pose();
  void set_allocated_cartesian_pose(::iiwa_com::CartesianPose* cartesian_pose);

  // .iiwa_com.CartesianState cartesian_state = 3;
  bool has_cartesian_state() const;
  void clear_cartesian_state();
  static const int kCartesianStateFieldNumber = 3;
  const ::iiwa_com::CartesianState& cartesian_state() const;
  ::iiwa_com::CartesianState* release_cartesian_state();
  ::iiwa_com::CartesianState* mutable_cartesian_state();
  void set_allocated_cartesian_state(::iiwa_com::CartesianState* cartesian_state);

  // .iiwa_com.CartesianForceRequest cartesian_force_request = 4;
  bool has_cartesian_force_request() const;
  void clear_cartesian_force_request();
  static const int kCartesianForceRequestFieldNumber = 4;
  const ::iiwa_com::CartesianForceRequest& cartesian_force_request() const;
  ::iiwa_com::CartesianForceRequest* release_cartesian_force_request();
  ::iiwa_com::CartesianForceRequest* mutable_cartesian_force_request();
  void set_allocated_cartesian_force_request(::iiwa_com::CartesianForceRequest* cartesian_force_request);

  // .iiwa_com.CartesianPoseRequest cartesian_pose_request = 5;
  bool has_cartesian_pose_request() const;
  void clear_cartesian_pose_request();
  static const int kCartesianPoseRequestFieldNumber = 5;
  const ::iiwa_com::CartesianPoseRequest& cartesian_pose_request() const;
  ::iiwa_com::CartesianPoseRequest* release_cartesian_pose_request();
  ::iiwa_com::CartesianPoseRequest* mutable_cartesian_pose_request();
  void set_allocated_cartesian_pose_request(::iiwa_com::CartesianPoseRequest* cartesian_pose_request);

  // .iiwa_com.CartesianStateRequest cartesian_state_request = 6;
  bool has_cartesian_state_request() const;
  void clear_cartesian_state_request();
  static const int kCartesianStateRequestFieldNumber = 6;
  const ::iiwa_com::CartesianStateRequest& cartesian_state_request() const;
  ::iiwa_com::CartesianStateRequest* release_cartesian_state_request();
  ::iiwa_com::CartesianStateRequest* mutable_cartesian_state_request();
  void set_allocated_cartesian_state_request(::iiwa_com::CartesianStateRequest* cartesian_state_request);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:iiwa_com.WrapperMsg)
 private:
  void set_has_cartesian_force();
  void set_has_cartesian_pose();
  void set_has_cartesian_state();
  void set_has_cartesian_force_request();
  void set_has_cartesian_pose_request();
  void set_has_cartesian_state_request();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MsgUnion {
    MsgUnion() {}
    ::iiwa_com::CartesianForce* cartesian_force_;
    ::iiwa_com::CartesianPose* cartesian_pose_;
    ::iiwa_com::CartesianState* cartesian_state_;
    ::iiwa_com::CartesianForceRequest* cartesian_force_request_;
    ::iiwa_com::CartesianPoseRequest* cartesian_pose_request_;
    ::iiwa_com::CartesianStateRequest* cartesian_state_request_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsWrapperMsgImpl();
};
// -------------------------------------------------------------------

class CartesianStateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.CartesianStateRequest) */ {
 public:
  CartesianStateRequest();
  virtual ~CartesianStateRequest();

  CartesianStateRequest(const CartesianStateRequest& from);

  inline CartesianStateRequest& operator=(const CartesianStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianStateRequest(CartesianStateRequest&& from) noexcept
    : CartesianStateRequest() {
    *this = ::std::move(from);
  }

  inline CartesianStateRequest& operator=(CartesianStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianStateRequest* internal_default_instance() {
    return reinterpret_cast<const CartesianStateRequest*>(
               &_CartesianStateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CartesianStateRequest* other);
  friend void swap(CartesianStateRequest& a, CartesianStateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianStateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianStateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianStateRequest& from);
  void MergeFrom(const CartesianStateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iiwa_com.CartesianStateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsCartesianStateRequestImpl();
};
// -------------------------------------------------------------------

class CartesianState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.CartesianState) */ {
 public:
  CartesianState();
  virtual ~CartesianState();

  CartesianState(const CartesianState& from);

  inline CartesianState& operator=(const CartesianState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianState(CartesianState&& from) noexcept
    : CartesianState() {
    *this = ::std::move(from);
  }

  inline CartesianState& operator=(CartesianState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianState* internal_default_instance() {
    return reinterpret_cast<const CartesianState*>(
               &_CartesianState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CartesianState* other);
  friend void swap(CartesianState& a, CartesianState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianState* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianState& from);
  void MergeFrom(const CartesianState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iiwa_com.CartesianPose demanded_pose = 1;
  bool has_demanded_pose() const;
  void clear_demanded_pose();
  static const int kDemandedPoseFieldNumber = 1;
  const ::iiwa_com::CartesianPose& demanded_pose() const;
  ::iiwa_com::CartesianPose* release_demanded_pose();
  ::iiwa_com::CartesianPose* mutable_demanded_pose();
  void set_allocated_demanded_pose(::iiwa_com::CartesianPose* demanded_pose);

  // .iiwa_com.CartesianPose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  const ::iiwa_com::CartesianPose& pose() const;
  ::iiwa_com::CartesianPose* release_pose();
  ::iiwa_com::CartesianPose* mutable_pose();
  void set_allocated_pose(::iiwa_com::CartesianPose* pose);

  // .iiwa_com.CartesianForce force = 3;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 3;
  const ::iiwa_com::CartesianForce& force() const;
  ::iiwa_com::CartesianForce* release_force();
  ::iiwa_com::CartesianForce* mutable_force();
  void set_allocated_force(::iiwa_com::CartesianForce* force);

  // .iiwa_com.CartesianForce force_uncertainty = 4;
  bool has_force_uncertainty() const;
  void clear_force_uncertainty();
  static const int kForceUncertaintyFieldNumber = 4;
  const ::iiwa_com::CartesianForce& force_uncertainty() const;
  ::iiwa_com::CartesianForce* release_force_uncertainty();
  ::iiwa_com::CartesianForce* mutable_force_uncertainty();
  void set_allocated_force_uncertainty(::iiwa_com::CartesianForce* force_uncertainty);

  // @@protoc_insertion_point(class_scope:iiwa_com.CartesianState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iiwa_com::CartesianPose* demanded_pose_;
  ::iiwa_com::CartesianPose* pose_;
  ::iiwa_com::CartesianForce* force_;
  ::iiwa_com::CartesianForce* force_uncertainty_;
  mutable int _cached_size_;
  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsCartesianStateImpl();
};
// -------------------------------------------------------------------

class CartesianPoseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.CartesianPoseRequest) */ {
 public:
  CartesianPoseRequest();
  virtual ~CartesianPoseRequest();

  CartesianPoseRequest(const CartesianPoseRequest& from);

  inline CartesianPoseRequest& operator=(const CartesianPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianPoseRequest(CartesianPoseRequest&& from) noexcept
    : CartesianPoseRequest() {
    *this = ::std::move(from);
  }

  inline CartesianPoseRequest& operator=(CartesianPoseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianPoseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianPoseRequest* internal_default_instance() {
    return reinterpret_cast<const CartesianPoseRequest*>(
               &_CartesianPoseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CartesianPoseRequest* other);
  friend void swap(CartesianPoseRequest& a, CartesianPoseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianPoseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianPoseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianPoseRequest& from);
  void MergeFrom(const CartesianPoseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianPoseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iiwa_com.CartesianPoseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsCartesianPoseRequestImpl();
};
// -------------------------------------------------------------------

class CartesianPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.CartesianPose) */ {
 public:
  CartesianPose();
  virtual ~CartesianPose();

  CartesianPose(const CartesianPose& from);

  inline CartesianPose& operator=(const CartesianPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianPose(CartesianPose&& from) noexcept
    : CartesianPose() {
    *this = ::std::move(from);
  }

  inline CartesianPose& operator=(CartesianPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianPose* internal_default_instance() {
    return reinterpret_cast<const CartesianPose*>(
               &_CartesianPose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CartesianPose* other);
  friend void swap(CartesianPose& a, CartesianPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianPose* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianPose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianPose& from);
  void MergeFrom(const CartesianPose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string base_frame = 7;
  void clear_base_frame();
  static const int kBaseFrameFieldNumber = 7;
  const ::std::string& base_frame() const;
  void set_base_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_base_frame(::std::string&& value);
  #endif
  void set_base_frame(const char* value);
  void set_base_frame(const char* value, size_t size);
  ::std::string* mutable_base_frame();
  ::std::string* release_base_frame();
  void set_allocated_base_frame(::std::string* base_frame);

  // string child_frame = 8;
  void clear_child_frame();
  static const int kChildFrameFieldNumber = 8;
  const ::std::string& child_frame() const;
  void set_child_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_child_frame(::std::string&& value);
  #endif
  void set_child_frame(const char* value);
  void set_child_frame(const char* value, size_t size);
  ::std::string* mutable_child_frame();
  ::std::string* release_child_frame();
  void set_allocated_child_frame(::std::string* child_frame);

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double a = 4;
  void clear_a();
  static const int kAFieldNumber = 4;
  double a() const;
  void set_a(double value);

  // double b = 5;
  void clear_b();
  static const int kBFieldNumber = 5;
  double b() const;
  void set_b(double value);

  // double c = 6;
  void clear_c();
  static const int kCFieldNumber = 6;
  double c() const;
  void set_c(double value);

  // @@protoc_insertion_point(class_scope:iiwa_com.CartesianPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr base_frame_;
  ::google::protobuf::internal::ArenaStringPtr child_frame_;
  double x_;
  double y_;
  double z_;
  double a_;
  double b_;
  double c_;
  mutable int _cached_size_;
  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsCartesianPoseImpl();
};
// -------------------------------------------------------------------

class CartesianForceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.CartesianForceRequest) */ {
 public:
  CartesianForceRequest();
  virtual ~CartesianForceRequest();

  CartesianForceRequest(const CartesianForceRequest& from);

  inline CartesianForceRequest& operator=(const CartesianForceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianForceRequest(CartesianForceRequest&& from) noexcept
    : CartesianForceRequest() {
    *this = ::std::move(from);
  }

  inline CartesianForceRequest& operator=(CartesianForceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianForceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianForceRequest* internal_default_instance() {
    return reinterpret_cast<const CartesianForceRequest*>(
               &_CartesianForceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CartesianForceRequest* other);
  friend void swap(CartesianForceRequest& a, CartesianForceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianForceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianForceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianForceRequest& from);
  void MergeFrom(const CartesianForceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianForceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iiwa_com.CartesianForceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsCartesianForceRequestImpl();
};
// -------------------------------------------------------------------

class CartesianForce : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iiwa_com.CartesianForce) */ {
 public:
  CartesianForce();
  virtual ~CartesianForce();

  CartesianForce(const CartesianForce& from);

  inline CartesianForce& operator=(const CartesianForce& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianForce(CartesianForce&& from) noexcept
    : CartesianForce() {
    *this = ::std::move(from);
  }

  inline CartesianForce& operator=(CartesianForce&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianForce& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianForce* internal_default_instance() {
    return reinterpret_cast<const CartesianForce*>(
               &_CartesianForce_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CartesianForce* other);
  friend void swap(CartesianForce& a, CartesianForce& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianForce* New() const PROTOBUF_FINAL { return New(NULL); }

  CartesianForce* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CartesianForce& from);
  void MergeFrom(const CartesianForce& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CartesianForce* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string frame = 7;
  void clear_frame();
  static const int kFrameFieldNumber = 7;
  const ::std::string& frame() const;
  void set_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_frame(::std::string&& value);
  #endif
  void set_frame(const char* value);
  void set_frame(const char* value, size_t size);
  ::std::string* mutable_frame();
  ::std::string* release_frame();
  void set_allocated_frame(::std::string* frame);

  // double f_x = 1;
  void clear_f_x();
  static const int kFXFieldNumber = 1;
  double f_x() const;
  void set_f_x(double value);

  // double f_y = 2;
  void clear_f_y();
  static const int kFYFieldNumber = 2;
  double f_y() const;
  void set_f_y(double value);

  // double f_z = 3;
  void clear_f_z();
  static const int kFZFieldNumber = 3;
  double f_z() const;
  void set_f_z(double value);

  // double t_x = 4;
  void clear_t_x();
  static const int kTXFieldNumber = 4;
  double t_x() const;
  void set_t_x(double value);

  // double t_y = 5;
  void clear_t_y();
  static const int kTYFieldNumber = 5;
  double t_y() const;
  void set_t_y(double value);

  // double t_z = 6;
  void clear_t_z();
  static const int kTZFieldNumber = 6;
  double t_z() const;
  void set_t_z(double value);

  // @@protoc_insertion_point(class_scope:iiwa_com.CartesianForce)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr frame_;
  double f_x_;
  double f_y_;
  double f_z_;
  double t_x_;
  double t_y_;
  double t_z_;
  mutable int _cached_size_;
  friend struct ::protobuf_iiwa_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_iiwa_5fmsgs_2eproto::InitDefaultsCartesianForceImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WrapperMsg

// .iiwa_com.CartesianForce cartesian_force = 1;
inline bool WrapperMsg::has_cartesian_force() const {
  return msg_case() == kCartesianForce;
}
inline void WrapperMsg::set_has_cartesian_force() {
  _oneof_case_[0] = kCartesianForce;
}
inline void WrapperMsg::clear_cartesian_force() {
  if (has_cartesian_force()) {
    delete msg_.cartesian_force_;
    clear_has_msg();
  }
}
inline ::iiwa_com::CartesianForce* WrapperMsg::release_cartesian_force() {
  // @@protoc_insertion_point(field_release:iiwa_com.WrapperMsg.cartesian_force)
  if (has_cartesian_force()) {
    clear_has_msg();
      ::iiwa_com::CartesianForce* temp = msg_.cartesian_force_;
    msg_.cartesian_force_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iiwa_com::CartesianForce& WrapperMsg::cartesian_force() const {
  // @@protoc_insertion_point(field_get:iiwa_com.WrapperMsg.cartesian_force)
  return has_cartesian_force()
      ? *msg_.cartesian_force_
      : *reinterpret_cast< ::iiwa_com::CartesianForce*>(&::iiwa_com::_CartesianForce_default_instance_);
}
inline ::iiwa_com::CartesianForce* WrapperMsg::mutable_cartesian_force() {
  if (!has_cartesian_force()) {
    clear_msg();
    set_has_cartesian_force();
    msg_.cartesian_force_ = new ::iiwa_com::CartesianForce;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.WrapperMsg.cartesian_force)
  return msg_.cartesian_force_;
}

// .iiwa_com.CartesianPose cartesian_pose = 2;
inline bool WrapperMsg::has_cartesian_pose() const {
  return msg_case() == kCartesianPose;
}
inline void WrapperMsg::set_has_cartesian_pose() {
  _oneof_case_[0] = kCartesianPose;
}
inline void WrapperMsg::clear_cartesian_pose() {
  if (has_cartesian_pose()) {
    delete msg_.cartesian_pose_;
    clear_has_msg();
  }
}
inline ::iiwa_com::CartesianPose* WrapperMsg::release_cartesian_pose() {
  // @@protoc_insertion_point(field_release:iiwa_com.WrapperMsg.cartesian_pose)
  if (has_cartesian_pose()) {
    clear_has_msg();
      ::iiwa_com::CartesianPose* temp = msg_.cartesian_pose_;
    msg_.cartesian_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iiwa_com::CartesianPose& WrapperMsg::cartesian_pose() const {
  // @@protoc_insertion_point(field_get:iiwa_com.WrapperMsg.cartesian_pose)
  return has_cartesian_pose()
      ? *msg_.cartesian_pose_
      : *reinterpret_cast< ::iiwa_com::CartesianPose*>(&::iiwa_com::_CartesianPose_default_instance_);
}
inline ::iiwa_com::CartesianPose* WrapperMsg::mutable_cartesian_pose() {
  if (!has_cartesian_pose()) {
    clear_msg();
    set_has_cartesian_pose();
    msg_.cartesian_pose_ = new ::iiwa_com::CartesianPose;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.WrapperMsg.cartesian_pose)
  return msg_.cartesian_pose_;
}

// .iiwa_com.CartesianState cartesian_state = 3;
inline bool WrapperMsg::has_cartesian_state() const {
  return msg_case() == kCartesianState;
}
inline void WrapperMsg::set_has_cartesian_state() {
  _oneof_case_[0] = kCartesianState;
}
inline void WrapperMsg::clear_cartesian_state() {
  if (has_cartesian_state()) {
    delete msg_.cartesian_state_;
    clear_has_msg();
  }
}
inline ::iiwa_com::CartesianState* WrapperMsg::release_cartesian_state() {
  // @@protoc_insertion_point(field_release:iiwa_com.WrapperMsg.cartesian_state)
  if (has_cartesian_state()) {
    clear_has_msg();
      ::iiwa_com::CartesianState* temp = msg_.cartesian_state_;
    msg_.cartesian_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iiwa_com::CartesianState& WrapperMsg::cartesian_state() const {
  // @@protoc_insertion_point(field_get:iiwa_com.WrapperMsg.cartesian_state)
  return has_cartesian_state()
      ? *msg_.cartesian_state_
      : *reinterpret_cast< ::iiwa_com::CartesianState*>(&::iiwa_com::_CartesianState_default_instance_);
}
inline ::iiwa_com::CartesianState* WrapperMsg::mutable_cartesian_state() {
  if (!has_cartesian_state()) {
    clear_msg();
    set_has_cartesian_state();
    msg_.cartesian_state_ = new ::iiwa_com::CartesianState;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.WrapperMsg.cartesian_state)
  return msg_.cartesian_state_;
}

// .iiwa_com.CartesianForceRequest cartesian_force_request = 4;
inline bool WrapperMsg::has_cartesian_force_request() const {
  return msg_case() == kCartesianForceRequest;
}
inline void WrapperMsg::set_has_cartesian_force_request() {
  _oneof_case_[0] = kCartesianForceRequest;
}
inline void WrapperMsg::clear_cartesian_force_request() {
  if (has_cartesian_force_request()) {
    delete msg_.cartesian_force_request_;
    clear_has_msg();
  }
}
inline ::iiwa_com::CartesianForceRequest* WrapperMsg::release_cartesian_force_request() {
  // @@protoc_insertion_point(field_release:iiwa_com.WrapperMsg.cartesian_force_request)
  if (has_cartesian_force_request()) {
    clear_has_msg();
      ::iiwa_com::CartesianForceRequest* temp = msg_.cartesian_force_request_;
    msg_.cartesian_force_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iiwa_com::CartesianForceRequest& WrapperMsg::cartesian_force_request() const {
  // @@protoc_insertion_point(field_get:iiwa_com.WrapperMsg.cartesian_force_request)
  return has_cartesian_force_request()
      ? *msg_.cartesian_force_request_
      : *reinterpret_cast< ::iiwa_com::CartesianForceRequest*>(&::iiwa_com::_CartesianForceRequest_default_instance_);
}
inline ::iiwa_com::CartesianForceRequest* WrapperMsg::mutable_cartesian_force_request() {
  if (!has_cartesian_force_request()) {
    clear_msg();
    set_has_cartesian_force_request();
    msg_.cartesian_force_request_ = new ::iiwa_com::CartesianForceRequest;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.WrapperMsg.cartesian_force_request)
  return msg_.cartesian_force_request_;
}

// .iiwa_com.CartesianPoseRequest cartesian_pose_request = 5;
inline bool WrapperMsg::has_cartesian_pose_request() const {
  return msg_case() == kCartesianPoseRequest;
}
inline void WrapperMsg::set_has_cartesian_pose_request() {
  _oneof_case_[0] = kCartesianPoseRequest;
}
inline void WrapperMsg::clear_cartesian_pose_request() {
  if (has_cartesian_pose_request()) {
    delete msg_.cartesian_pose_request_;
    clear_has_msg();
  }
}
inline ::iiwa_com::CartesianPoseRequest* WrapperMsg::release_cartesian_pose_request() {
  // @@protoc_insertion_point(field_release:iiwa_com.WrapperMsg.cartesian_pose_request)
  if (has_cartesian_pose_request()) {
    clear_has_msg();
      ::iiwa_com::CartesianPoseRequest* temp = msg_.cartesian_pose_request_;
    msg_.cartesian_pose_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iiwa_com::CartesianPoseRequest& WrapperMsg::cartesian_pose_request() const {
  // @@protoc_insertion_point(field_get:iiwa_com.WrapperMsg.cartesian_pose_request)
  return has_cartesian_pose_request()
      ? *msg_.cartesian_pose_request_
      : *reinterpret_cast< ::iiwa_com::CartesianPoseRequest*>(&::iiwa_com::_CartesianPoseRequest_default_instance_);
}
inline ::iiwa_com::CartesianPoseRequest* WrapperMsg::mutable_cartesian_pose_request() {
  if (!has_cartesian_pose_request()) {
    clear_msg();
    set_has_cartesian_pose_request();
    msg_.cartesian_pose_request_ = new ::iiwa_com::CartesianPoseRequest;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.WrapperMsg.cartesian_pose_request)
  return msg_.cartesian_pose_request_;
}

// .iiwa_com.CartesianStateRequest cartesian_state_request = 6;
inline bool WrapperMsg::has_cartesian_state_request() const {
  return msg_case() == kCartesianStateRequest;
}
inline void WrapperMsg::set_has_cartesian_state_request() {
  _oneof_case_[0] = kCartesianStateRequest;
}
inline void WrapperMsg::clear_cartesian_state_request() {
  if (has_cartesian_state_request()) {
    delete msg_.cartesian_state_request_;
    clear_has_msg();
  }
}
inline ::iiwa_com::CartesianStateRequest* WrapperMsg::release_cartesian_state_request() {
  // @@protoc_insertion_point(field_release:iiwa_com.WrapperMsg.cartesian_state_request)
  if (has_cartesian_state_request()) {
    clear_has_msg();
      ::iiwa_com::CartesianStateRequest* temp = msg_.cartesian_state_request_;
    msg_.cartesian_state_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iiwa_com::CartesianStateRequest& WrapperMsg::cartesian_state_request() const {
  // @@protoc_insertion_point(field_get:iiwa_com.WrapperMsg.cartesian_state_request)
  return has_cartesian_state_request()
      ? *msg_.cartesian_state_request_
      : *reinterpret_cast< ::iiwa_com::CartesianStateRequest*>(&::iiwa_com::_CartesianStateRequest_default_instance_);
}
inline ::iiwa_com::CartesianStateRequest* WrapperMsg::mutable_cartesian_state_request() {
  if (!has_cartesian_state_request()) {
    clear_msg();
    set_has_cartesian_state_request();
    msg_.cartesian_state_request_ = new ::iiwa_com::CartesianStateRequest;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.WrapperMsg.cartesian_state_request)
  return msg_.cartesian_state_request_;
}

inline bool WrapperMsg::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void WrapperMsg::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline WrapperMsg::MsgCase WrapperMsg::msg_case() const {
  return WrapperMsg::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CartesianStateRequest

// -------------------------------------------------------------------

// CartesianState

// .iiwa_com.CartesianPose demanded_pose = 1;
inline bool CartesianState::has_demanded_pose() const {
  return this != internal_default_instance() && demanded_pose_ != NULL;
}
inline void CartesianState::clear_demanded_pose() {
  if (GetArenaNoVirtual() == NULL && demanded_pose_ != NULL) {
    delete demanded_pose_;
  }
  demanded_pose_ = NULL;
}
inline const ::iiwa_com::CartesianPose& CartesianState::demanded_pose() const {
  const ::iiwa_com::CartesianPose* p = demanded_pose_;
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianState.demanded_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::iiwa_com::CartesianPose*>(
      &::iiwa_com::_CartesianPose_default_instance_);
}
inline ::iiwa_com::CartesianPose* CartesianState::release_demanded_pose() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianState.demanded_pose)
  
  ::iiwa_com::CartesianPose* temp = demanded_pose_;
  demanded_pose_ = NULL;
  return temp;
}
inline ::iiwa_com::CartesianPose* CartesianState::mutable_demanded_pose() {
  
  if (demanded_pose_ == NULL) {
    demanded_pose_ = new ::iiwa_com::CartesianPose;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianState.demanded_pose)
  return demanded_pose_;
}
inline void CartesianState::set_allocated_demanded_pose(::iiwa_com::CartesianPose* demanded_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete demanded_pose_;
  }
  if (demanded_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      demanded_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, demanded_pose, submessage_arena);
    }
    
  } else {
    
  }
  demanded_pose_ = demanded_pose;
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianState.demanded_pose)
}

// .iiwa_com.CartesianPose pose = 2;
inline bool CartesianState::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void CartesianState::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}
inline const ::iiwa_com::CartesianPose& CartesianState::pose() const {
  const ::iiwa_com::CartesianPose* p = pose_;
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianState.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::iiwa_com::CartesianPose*>(
      &::iiwa_com::_CartesianPose_default_instance_);
}
inline ::iiwa_com::CartesianPose* CartesianState::release_pose() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianState.pose)
  
  ::iiwa_com::CartesianPose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::iiwa_com::CartesianPose* CartesianState::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::iiwa_com::CartesianPose;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianState.pose)
  return pose_;
}
inline void CartesianState::set_allocated_pose(::iiwa_com::CartesianPose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianState.pose)
}

// .iiwa_com.CartesianForce force = 3;
inline bool CartesianState::has_force() const {
  return this != internal_default_instance() && force_ != NULL;
}
inline void CartesianState::clear_force() {
  if (GetArenaNoVirtual() == NULL && force_ != NULL) {
    delete force_;
  }
  force_ = NULL;
}
inline const ::iiwa_com::CartesianForce& CartesianState::force() const {
  const ::iiwa_com::CartesianForce* p = force_;
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianState.force)
  return p != NULL ? *p : *reinterpret_cast<const ::iiwa_com::CartesianForce*>(
      &::iiwa_com::_CartesianForce_default_instance_);
}
inline ::iiwa_com::CartesianForce* CartesianState::release_force() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianState.force)
  
  ::iiwa_com::CartesianForce* temp = force_;
  force_ = NULL;
  return temp;
}
inline ::iiwa_com::CartesianForce* CartesianState::mutable_force() {
  
  if (force_ == NULL) {
    force_ = new ::iiwa_com::CartesianForce;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianState.force)
  return force_;
}
inline void CartesianState::set_allocated_force(::iiwa_com::CartesianForce* force) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete force_;
  }
  if (force) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      force = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    
  } else {
    
  }
  force_ = force;
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianState.force)
}

// .iiwa_com.CartesianForce force_uncertainty = 4;
inline bool CartesianState::has_force_uncertainty() const {
  return this != internal_default_instance() && force_uncertainty_ != NULL;
}
inline void CartesianState::clear_force_uncertainty() {
  if (GetArenaNoVirtual() == NULL && force_uncertainty_ != NULL) {
    delete force_uncertainty_;
  }
  force_uncertainty_ = NULL;
}
inline const ::iiwa_com::CartesianForce& CartesianState::force_uncertainty() const {
  const ::iiwa_com::CartesianForce* p = force_uncertainty_;
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianState.force_uncertainty)
  return p != NULL ? *p : *reinterpret_cast<const ::iiwa_com::CartesianForce*>(
      &::iiwa_com::_CartesianForce_default_instance_);
}
inline ::iiwa_com::CartesianForce* CartesianState::release_force_uncertainty() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianState.force_uncertainty)
  
  ::iiwa_com::CartesianForce* temp = force_uncertainty_;
  force_uncertainty_ = NULL;
  return temp;
}
inline ::iiwa_com::CartesianForce* CartesianState::mutable_force_uncertainty() {
  
  if (force_uncertainty_ == NULL) {
    force_uncertainty_ = new ::iiwa_com::CartesianForce;
  }
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianState.force_uncertainty)
  return force_uncertainty_;
}
inline void CartesianState::set_allocated_force_uncertainty(::iiwa_com::CartesianForce* force_uncertainty) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete force_uncertainty_;
  }
  if (force_uncertainty) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      force_uncertainty = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, force_uncertainty, submessage_arena);
    }
    
  } else {
    
  }
  force_uncertainty_ = force_uncertainty;
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianState.force_uncertainty)
}

// -------------------------------------------------------------------

// CartesianPoseRequest

// -------------------------------------------------------------------

// CartesianPose

// double x = 1;
inline void CartesianPose::clear_x() {
  x_ = 0;
}
inline double CartesianPose::x() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.x)
  return x_;
}
inline void CartesianPose::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.x)
}

// double y = 2;
inline void CartesianPose::clear_y() {
  y_ = 0;
}
inline double CartesianPose::y() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.y)
  return y_;
}
inline void CartesianPose::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.y)
}

// double z = 3;
inline void CartesianPose::clear_z() {
  z_ = 0;
}
inline double CartesianPose::z() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.z)
  return z_;
}
inline void CartesianPose::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.z)
}

// double a = 4;
inline void CartesianPose::clear_a() {
  a_ = 0;
}
inline double CartesianPose::a() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.a)
  return a_;
}
inline void CartesianPose::set_a(double value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.a)
}

// double b = 5;
inline void CartesianPose::clear_b() {
  b_ = 0;
}
inline double CartesianPose::b() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.b)
  return b_;
}
inline void CartesianPose::set_b(double value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.b)
}

// double c = 6;
inline void CartesianPose::clear_c() {
  c_ = 0;
}
inline double CartesianPose::c() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.c)
  return c_;
}
inline void CartesianPose::set_c(double value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.c)
}

// string base_frame = 7;
inline void CartesianPose::clear_base_frame() {
  base_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CartesianPose::base_frame() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.base_frame)
  return base_frame_.GetNoArena();
}
inline void CartesianPose::set_base_frame(const ::std::string& value) {
  
  base_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.base_frame)
}
#if LANG_CXX11
inline void CartesianPose::set_base_frame(::std::string&& value) {
  
  base_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iiwa_com.CartesianPose.base_frame)
}
#endif
inline void CartesianPose::set_base_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  base_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iiwa_com.CartesianPose.base_frame)
}
inline void CartesianPose::set_base_frame(const char* value, size_t size) {
  
  base_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iiwa_com.CartesianPose.base_frame)
}
inline ::std::string* CartesianPose::mutable_base_frame() {
  
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianPose.base_frame)
  return base_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CartesianPose::release_base_frame() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianPose.base_frame)
  
  return base_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CartesianPose::set_allocated_base_frame(::std::string* base_frame) {
  if (base_frame != NULL) {
    
  } else {
    
  }
  base_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base_frame);
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianPose.base_frame)
}

// string child_frame = 8;
inline void CartesianPose::clear_child_frame() {
  child_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CartesianPose::child_frame() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianPose.child_frame)
  return child_frame_.GetNoArena();
}
inline void CartesianPose::set_child_frame(const ::std::string& value) {
  
  child_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianPose.child_frame)
}
#if LANG_CXX11
inline void CartesianPose::set_child_frame(::std::string&& value) {
  
  child_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iiwa_com.CartesianPose.child_frame)
}
#endif
inline void CartesianPose::set_child_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  child_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iiwa_com.CartesianPose.child_frame)
}
inline void CartesianPose::set_child_frame(const char* value, size_t size) {
  
  child_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iiwa_com.CartesianPose.child_frame)
}
inline ::std::string* CartesianPose::mutable_child_frame() {
  
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianPose.child_frame)
  return child_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CartesianPose::release_child_frame() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianPose.child_frame)
  
  return child_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CartesianPose::set_allocated_child_frame(::std::string* child_frame) {
  if (child_frame != NULL) {
    
  } else {
    
  }
  child_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), child_frame);
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianPose.child_frame)
}

// -------------------------------------------------------------------

// CartesianForceRequest

// -------------------------------------------------------------------

// CartesianForce

// double f_x = 1;
inline void CartesianForce::clear_f_x() {
  f_x_ = 0;
}
inline double CartesianForce::f_x() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.f_x)
  return f_x_;
}
inline void CartesianForce::set_f_x(double value) {
  
  f_x_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.f_x)
}

// double f_y = 2;
inline void CartesianForce::clear_f_y() {
  f_y_ = 0;
}
inline double CartesianForce::f_y() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.f_y)
  return f_y_;
}
inline void CartesianForce::set_f_y(double value) {
  
  f_y_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.f_y)
}

// double f_z = 3;
inline void CartesianForce::clear_f_z() {
  f_z_ = 0;
}
inline double CartesianForce::f_z() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.f_z)
  return f_z_;
}
inline void CartesianForce::set_f_z(double value) {
  
  f_z_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.f_z)
}

// double t_x = 4;
inline void CartesianForce::clear_t_x() {
  t_x_ = 0;
}
inline double CartesianForce::t_x() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.t_x)
  return t_x_;
}
inline void CartesianForce::set_t_x(double value) {
  
  t_x_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.t_x)
}

// double t_y = 5;
inline void CartesianForce::clear_t_y() {
  t_y_ = 0;
}
inline double CartesianForce::t_y() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.t_y)
  return t_y_;
}
inline void CartesianForce::set_t_y(double value) {
  
  t_y_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.t_y)
}

// double t_z = 6;
inline void CartesianForce::clear_t_z() {
  t_z_ = 0;
}
inline double CartesianForce::t_z() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.t_z)
  return t_z_;
}
inline void CartesianForce::set_t_z(double value) {
  
  t_z_ = value;
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.t_z)
}

// string frame = 7;
inline void CartesianForce::clear_frame() {
  frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CartesianForce::frame() const {
  // @@protoc_insertion_point(field_get:iiwa_com.CartesianForce.frame)
  return frame_.GetNoArena();
}
inline void CartesianForce::set_frame(const ::std::string& value) {
  
  frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iiwa_com.CartesianForce.frame)
}
#if LANG_CXX11
inline void CartesianForce::set_frame(::std::string&& value) {
  
  frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iiwa_com.CartesianForce.frame)
}
#endif
inline void CartesianForce::set_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iiwa_com.CartesianForce.frame)
}
inline void CartesianForce::set_frame(const char* value, size_t size) {
  
  frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iiwa_com.CartesianForce.frame)
}
inline ::std::string* CartesianForce::mutable_frame() {
  
  // @@protoc_insertion_point(field_mutable:iiwa_com.CartesianForce.frame)
  return frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CartesianForce::release_frame() {
  // @@protoc_insertion_point(field_release:iiwa_com.CartesianForce.frame)
  
  return frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CartesianForce::set_allocated_frame(::std::string* frame) {
  if (frame != NULL) {
    
  } else {
    
  }
  frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame);
  // @@protoc_insertion_point(field_set_allocated:iiwa_com.CartesianForce.frame)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace iiwa_com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_iiwa_5fmsgs_2eproto__INCLUDED
